# *** Notes ***
# mirar space_view3d_align_tools.py
#
# ##### BEGIN GPL LICENSE BLOCK #####
#
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License, or (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software Foundation,
#  Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
#
###### END GPL LICENSE BLOCK #####

# <pep8 compliant>

bl_info = {
    'name': 'Blender maker',
    'author': 'Miguel Jimenez <miguel.jgz@gmail.com>',
    'version': (0, 1),
    "blender": (2, 5, 8),
    "api": 35622,
    'location': '',
    'description': 'Extension of blender for Open hardware 3D printing.',
    'warning': '',
    'wiki_url': '',
    'tracker_url': '',
    'category': 'CNC'}

'''
-------------------------------------------------------------------------
Rev 0.1 Blender 2.5 support.
-------------------------------------------------------------------------
'''

import bpy
from bpy import* 
import os,sys
import struct
import mmap
import contextlib
import itertools
import mathutils
from bpy.props import StringProperty, BoolProperty, CollectionProperty
from bpy_extras.io_utils import ExportHelper, ImportHelper
from bpy.props import IntProperty, BoolProperty, FloatVectorProperty

######
# UI #
######

class BMUI(bpy.types.Panel):
    bl_space_type = 'VIEW_3D'
    bl_region_type = 'TOOLS'
    bl_label = "Blender Maker"
    bl_context = "objectmode"

    def draw(self, context):

        #capture
        layout = self.layout
        obj = context.object
        scene = context.scene

        #save file.
        col = layout.column(align=True)
        row = col.row()
        row = layout.row()
        
        col.label(text="STL file", icon='FILE')
        col = layout.column()
        col = layout.column_flow(columns=5,align=True)
        row.operator("export_mesh.stl", text="Save")
        row.operator("import_mesh.stl", text="Load")
        
        box = layout.separator()        
        
        #select view from.
        col = layout.column()
        col.label(text="View from:", icon='MANIPUL')
        col = layout.column_flow(columns=5,align=True)
        col.operator("view3d.viewnumpad",text="X").type='LEFT'
        col.operator("view3d.viewnumpad",text="Y").type='FRONT'
        col.operator("view3d.viewnumpad",text="Z").type='TOP'
                
        #Scale
        col = layout.column(align=True)
        col.label(text="Scale object:", icon='MAN_SCALE')

        row = col.row()
        row.prop( scene, "scaleX" )
        row = col.row()
        row.prop( scene, "scaleY" )
        row = col.row()
        row.prop( scene, "scaleZ" )
        
        box = layout.separator()        
        
        col = layout.column(align=True)
        row = col.row()
        row.label(text="Randomize:", icon='FORCE_TURBULENCE')
        row = col.row()
        row.prop( scene, "randomMagnitude" )
        row = col.row()
        row.operator("object.randomize", text="Randomize")

        #Events capturers.
        scaleXval = bpy.context.scene.scaleX
        event_scaleX(scaleXval)
        scaleYval = bpy.context.scene.scaleY
        event_scaleY(scaleYval)
        scaleZval = bpy.context.scene.scaleZ
        event_scaleZ(scaleZval)
        
        randomMag = bpy.context.scene.randomMagnitude
        event_randomMagnitude(randomMag)


        
#############
# Operators #
#############

class AlignOperator(bpy.types.Operator):
    ''''''
    bl_idname = "object.align"
    bl_label = "Align Selected To Active"

    @classmethod
    def poll(cls, context):
        return context.active_object != None

    def execute(self, context):
        print("in Align Operator")
        return {'FINISHED'}


class randomizeObject(bpy.types.Operator):
    ''''''
    bl_idname = "object.randomize"
    bl_label = "Randomize selected object"


    @classmethod
    def poll(cls, context):
        return context.active_object != None

    def execute(self, context):
        print("in randomize operator")
        randomize_selected(0,False,(0.0,0.0,0.0),(0.0,0.0,0.0),(10.0,9.0,3.0),False)
        return {'FINISHED'}

class saveFile(bpy.types.Operator):
    ''''''
    bl_idname = "file.save"
    bl_label = "Save the object in stl file"

    @classmethod
    def poll(cls, context):
        
        return context.active_object != None

    def execute(self, context):
        print("In save file operator")    
        layout = self.layout
        obj = context.object
        ##############################################mod
        mesh=bpy.data.scenes[0].objects[obj.name].data
        
        print()
        #write_stl("ficherosalva.stl",mesh.faces)
        
        return {'FINISHED'}


class mod(object):
    def __init__(self):
        self._x = None

    @property
    def x(self):
        """I'm the 'x' property."""
        return self._x

    @x.setter
    def x(self, value):
        self._x = value

    @x.deleter
    def x(self):
        del self._x


## file exporter ##
class ExportSTL(bpy.types.Operator, ExportHelper):
    '''
    Save STL triangle mesh data from the active object
    '''
    bl_idname = "export_mesh.stl"
    bl_label = "Export STL"

    filename_ext = ".stl"

    ascii = BoolProperty(name="Ascii",
                         description="Save the file in ASCII file format",
                         default=False)
    apply_modifiers = BoolProperty(name="Apply Modifiers",
                                   description="Apply the modifiers "
                                               "before saving",
                                   default=True)

    def execute(self, context):
        from . import stl_utils
        from . import blender_utils
        import itertools

        faces = itertools.chain.from_iterable(
            blender_utils.faces_from_mesh(ob, self.apply_modifiers)
            for ob in context.selected_objects)

        stl_utils.write_stl(self.filepath, faces, self.ascii)

        return {'FINISHED'}


##############
# Registring #
##############


def register():

    bpy.utils.register_class(AlignOperator)
    bpy.utils.register_class(randomizeObject)
    bpy.utils.register_class(BMUI)
    #bpy.utils.register_class(saveFile)
    bpy.utils.register_class(ExportSTL)

    scnType = bpy.types.Scene
    scnType.scaleX = bpy.props.FloatProperty( name = "X", 
                                                     default = 0, min = -20, max = 20, 
                                                     description = "Scale object in X axys" ,update=up_func)
    
    scnType = bpy.types.Scene
    scnType.scaleY = bpy.props.FloatProperty( name = "Y", 
                                                     default = 0, min = -20, max = 20, 
                                                     description = "Scale object in Y axys" )
    
    scnType = bpy.types.Scene
    scnType.scaleZ = bpy.props.FloatProperty( name = "Z", 
                                                     default = 0, min = -20, max = 20, 
                                                     description = "Scale object in Z axys" )
    
    scnType = bpy.types.Scene
    scnType.randomMagnitude = bpy.props.IntProperty( name = "Randomize", 
                                                     default = 0, min = -20, max = 20, 
                                                     description = "Randomize object" )


    scale = FloatVectorProperty(name="Scale",
        description="Maximum scale randomization over each axis",
        default=(0.0, 0.0, 0.0), min=-100.0, max=100.0, subtype='TRANSLATION')
    

    bpy.types.Scene.testprop = bpy.props.FloatProperty(update=up_func)

    pass

def up_func(self, context):
    print("test")


def unregister():
    bpy.utils.register_class(AlignOperator)
    bpy.utils.register_class(randomizeObject)
    bpy.utils.register_class(BMUI)
    #bpy.utils.register_class(saveFile)
    bpy.utils.register_class(ExportSTL)
    pass

if __name__ == "__main__":
    register()


##########
# Events #
##########

scaleXBuff=0
def event_scaleX(scaleX):
    global scaleXBuff
    if(scaleX!=scaleXBuff):
        print("** Event scalex")
        obj = context.object
        #print(getx(obj))
        #obj.size=[float(scaleX),float(scaleX),float(obj.dimensions[2])]
        #mesh=bpy.data.scenes[0].objects[obj.name].data
        #print(mesh.dimesions)
        #obj.location = (0,0,0)                # set distance from origin
        #randomize_selected(0,False,(0.0,0.0,0.0),(0.0,0.0,0.0),(10.0,9.0,3.0),False)
        
        scaleXBuff=scaleX

scaleYBuff=0
def event_scaleY(scaleY):
    global scaleYBuff
    if(scaleY!=scaleYBuff):
        print("** Event scaley")
    scaleYBuff=scaleY

scaleZBuff=0
def event_scaleZ(scaleZ):
    global scaleZBuff
    if(scaleZ!=scaleZBuff):
        print("** Event scalez")
    scaleZBuff=scaleZ


randomMagBuff=0
def event_randomMagnitude(randomMag):
    global randomMagBuff
    if(randomMag!=randomMagBuff):
        print("** Event randomize")
    
        
    randomMagBuff=randomMag
    
    
#############
# Functions #
#############

def exportSTL_old(obj):
    print("Object to save:"+obj.name)
    #print(bpy.data.scenes[0].objects[obj.name].data.vertices[0].co)
    mesh=bpy.data.scenes[0].objects[obj.name].data

    file = open("/home/miguel/objects/temporal2.stl","w")
    file.write("solid "+"temporal2.stl"+"\n")
    
    #face=mesh.faces
    #print(face[9].vertices[:])

    n_tri=0 # number of tris in STL                                                                 
    n_face=len(mesh.faces)                                                                          
    
    #print(mesh.vertices[1].co[0])
    

    for i in range(0,n_face):                                                                       	
        face=mesh.faces[i]                                                            
        nx=face.normal[0]                                                                         
        ny=face.normal[1]                                                                         
        nz=face.normal[2]                                                                         
        n_vert=len(face.vertices)                                                                    
        if n_vert>2:                                                                          
            file.write("facet normal "+str(nx)+" "+str(ny)+" "+str(nz)+"\n")              
            file.write("  outer loop")                                                    
            for j in range(0,3):                                                          
                vert=face.vertices[j]                                                        
                file.write("\n    vertex")                                            
                for k in range(0,3):                                                  
                    file.write(" "+str(mesh.vertices[vert].co[k]))
            file.write("\n  endloop\n")
            file.write("endfacet\n")
            n_tri=n_tri+1
            if n_vert>3:                                                                    
                file.write("facet normal "+str(nx)+" "+str(ny)+" "+str(nz)+"\n")        
                file.write("  outer loop")                                              
                for j in [0,2,3]:                                                       
                    vert=face.vertices[j]                                                  
                    file.write("\n    vertex")                                      
                    for k in range(0,3):                                            
                        file.write(" "+str(mesh.vertices[vert].co[k]))                            
                    file.write("\n  endloop\n")                                             
                    file.write("endfacet\n")                                                
                    n_tri=n_tri+1                                                          
    file.write("endsolid\n")                                                                       
    file.close()                                                                                   


# Writing stl#
def write_stl(filename, faces, ascii=False):
    '''
    Write a stl file from faces,

    filename
       output filename

    faces
       iterable of tuple of 3 vertex, vertex is tuple of 3 coordinates as float

    ascii
       save the file in ascii format (very huge)
    '''
    print("** In write_stl")
    (_ascii_write if ascii else _binary_write)(filename, faces)

def _ascii_write(filename, faces):
    with open(filename, 'w') as data:
        data.write('solid Exported from blender\n')

        for face in faces:
            data.write('''facet normal 0 0 0\nouter loop\n''')
            for vert in face:
                data.write('vertex %f %f %f\n' % vert)
            data.write('endloop\nendfacet\n')

        data.write('endsolid Exported from blender\n')

def _binary_write(filename, faces):
    with open(filename, 'wb') as data:
        # header
        # we write padding at header begginning to avoid to
        # call len(list(faces)) which may be expensive
        data.write(struct.calcsize('<80sI') * b'\0')

        # 3 vertex == 9f
        pack = struct.Struct('<9f').pack
        # pad is to remove normal, we do use them
        pad = b'\0' * struct.calcsize('<3f')

        nb = 0
        for verts in faces:
            # write pad as normal + vertexes + pad as attributes
            data.write(pad + pack(*itertools.chain.from_iterable(verts)))
            data.write(b'\0\0')
            nb += 1

        # header, with correct value now
        data.seek(0)
        data.write(struct.pack('<80sI', b"Exported from blender", nb))



## Randomization ##
def randomize_selected(seed, delta, loc, rot, scale, scale_even):
    import random
    from random import uniform
    from mathutils import Vector

    random.seed(seed)
    
    def rand_vec(vec_range):
        return Vector(uniform(-val, val) for val in vec_range)

    for obj in bpy.context.selected_objects:

        if loc:
            if delta:
                obj.delta_location += rand_vec(loc)
            else:
                obj.location += rand_vec(loc)
        else:  # otherwise the values change under us
            uniform(0.0, 0.0), uniform(0.0, 0.0), uniform(0.0, 0.0)

        if rot:  # TODO, non euler's
            vec = rand_vec(rot)
            if delta:
                obj.delta_rotation_euler[0] += vec[0]
                obj.delta_rotation_euler[1] += vec[1]
                obj.delta_rotation_euler[2] += vec[2]
            else:
                obj.rotation_euler[0] += vec[0]
                obj.rotation_euler[1] += vec[1]
                obj.rotation_euler[2] += vec[2]
        else:
            uniform(0.0, 0.0), uniform(0.0, 0.0), uniform(0.0, 0.0)

        if scale:
            if delta:
                org_sca_x, org_sca_y, org_sca_z = obj.delta_scale
            else:
                org_sca_x, org_sca_y, org_sca_z = obj.scale

            if scale_even:
                sca_x = sca_y = sca_z = uniform(scale[0], - scale[0])
                uniform(0.0, 0.0), uniform(0.0, 0.0)
            else:
                sca_x, sca_y, sca_z = rand_vec(scale)

            if scale_even:
                aX = -(sca_x * org_sca_x) + org_sca_x
                aY = -(sca_x * org_sca_y) + org_sca_y
                aZ = -(sca_x * org_sca_z) + org_sca_z
            else:
                aX = sca_x + org_sca_x
                aY = sca_y + org_sca_y
                aZ = sca_z + org_sca_z

            if delta:
                obj.delta_scale = aX, aY, aZ
            else:
                obj.scale = aX, aY, aZ
        else:
            uniform(0.0, 0.0), uniform(0.0, 0.0), uniform(0.0, 0.0)

        
